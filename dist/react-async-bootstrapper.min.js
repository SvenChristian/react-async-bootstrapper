'use strict'
var defaultOptions = { componentWillUnmount: !1 },
  forwardRefSymbol = Symbol.for('react.forward_ref'),
  pReduce = function(e, p, t) {
    return new Promise(function(r, o) {
      var i = e[Symbol.iterator](),
        s = 0
      !(function t(e) {
        var n = i.next()
        n.done
          ? r(e)
          : Promise.all([e, n.value])
              .then(function(e) {
                t(p(e[0], e[1], s++))
              })
              .catch(o)
      })(t)
    })
  },
  pMapSeries = function(e, r) {
    var o = []
    return pReduce(e, function(e, t, n) {
      return Promise.resolve(r(t, n)).then(function(e) {
        o.push(e)
      })
    }).then(function() {
      return o
    })
  },
  ensureChild = function e(t) {
    return t && 'function' == typeof t.render ? e(t.render()) : t
  },
  getChildren = function(e) {
    return e.props && e.props.children
      ? e.props.children
      : e.children
        ? e.children
        : void 0
  },
  getType = function(e) {
    return e.type || e.nodeName
  },
  getProps = function(e) {
    return e.props || e.attributes
  },
  isReactElement = function(e) {
    return !!getType(e)
  },
  isClassComponent = function(e) {
    return (
      e.prototype &&
      (e.prototype.render ||
        e.prototype.isReactComponent ||
        e.prototype.isPureReactComponent)
    )
  },
  isForwardRef = function(e) {
    return e.type && e.type.$$typeof === forwardRefSymbol
  },
  providesChildContext = function(e) {
    return !!e.getChildContext
  }
function reactTreeWalker(t, n, r) {
  var f =
    3 < arguments.length && void 0 !== arguments[3]
      ? arguments[3]
      : defaultOptions
  return new Promise(function(e, a) {
    var l = function() {
      try {
        return n.apply(void 0, arguments)
      } catch (e) {
        a(e)
      }
    }
    ;(function p(u, c) {
      if (Array.isArray(u))
        return Promise.all(
          u.map(function(e) {
            return p(e, c)
          }),
        )
      if (!u) return Promise.resolve()
      if ('string' == typeof u || 'number' == typeof u)
        return l(u, null, c), Promise.resolve()
      if (u.type) {
        var e = u.type._context || (u.type.Provider && u.type.Provider._context)
        if (
          e &&
          ('value' in u.props &&
            (u.type._context._currentValue = u.props.value),
          'function' == typeof u.props.children)
        ) {
          var t = u.props.children(e._currentValue)
          return p(t, c)
        }
      }
      return isReactElement(u)
        ? new Promise(function(i) {
            var e = function(r, e, t, o) {
              return Promise.resolve(l(u, e, t, o))
                .then(function(e) {
                  if (!1 !== e) {
                    var t = r(),
                      n = ensureChild(t)
                    if (n)
                      return Array.isArray(n)
                        ? pMapSeries(n, function(e) {
                            return e ? p(e, o) : Promise.resolve()
                          })
                            .then(i, a)
                            .catch(a)
                        : p(n, o)
                            .then(i, a)
                            .catch(a)
                  }
                })
                .catch(a)
            }
            if ('function' == typeof getType(u) || isForwardRef(u)) {
              var t = getType(u),
                n = Object.assign({}, t.defaultProps, getProps(u), {
                  children: getChildren(u),
                })
              if (isForwardRef(u))
                e(
                  function() {
                    return u.type.render(n)
                  },
                  null,
                  c,
                  c,
                ).then(i)
              else if (isClassComponent(t)) {
                var r = new t(n, c)
                if (
                  (Object.defineProperty(r, 'props', { value: r.props || n }),
                  (r.context = r.context || c),
                  (r.state = r.state || null),
                  (r.setState = function(e) {
                    'function' == typeof e &&
                      (e = e(r.state, r.props, r.context)),
                      (r.state = Object.assign({}, r.state, e))
                  }),
                  t.getDerivedStateFromProps)
                ) {
                  var o = t.getDerivedStateFromProps(r.props, r.state)
                  null !== o && (r.state = Object.assign({}, r.state, o))
                } else
                  r.UNSAFE_componentWillMount
                    ? r.UNSAFE_componentWillMount()
                    : r.componentWillMount && r.componentWillMount()
                var s = providesChildContext(r)
                  ? Object.assign({}, c, r.getChildContext())
                  : c
                e(
                  function() {
                    return r.render(r.props, r.state)
                  },
                  r,
                  c,
                  s,
                )
                  .then(function() {
                    f.componentWillUnmount &&
                      r.componentWillUnmount &&
                      r.componentWillUnmount()
                  })
                  .then(i)
              } else
                e(
                  function() {
                    return t(n, c)
                  },
                  null,
                  c,
                  c,
                ).then(i)
            } else
              e(
                function() {
                  return getChildren(u)
                },
                null,
                c,
                c,
              ).then(i)
          })
        : u.containerInfo &&
          u.children &&
          u.children.props &&
          Array.isArray(u.children.props.children)
          ? Promise.all(
              u.children.props.children.map(function(e) {
                return p(e, c)
              }),
            )
          : Promise.resolve()
    })(t, r).then(e, a)
  })
}
var warnmsg =
    '"react-async-bootstrapper" deprecation notice: please rename your "asyncBootsrap" methods to "bootstrap"',
  defaultContext = { reactAsyncBootstrapperRunning: !0 }
function asyncBootstrapper(e, t) {
  var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}
  return reactTreeWalker(
    e,
    function(e, t) {
      if (
        t &&
        ('function' == typeof t.asyncBootstrap ||
          'function' == typeof t.bootstrap)
      )
        return 'function' == typeof t.bootstrap
          ? t.bootstrap()
          : console.log(warnmsg) || t.asyncBootstrap()
    },
    Object.assign({}, n, defaultContext),
    t,
  )
}
module.exports = asyncBootstrapper
//# sourceMappingURL=react-async-bootstrapper.min.js.map
